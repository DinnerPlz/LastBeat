// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel diffusion
#pragma kernel advect
#pragma kernel add_source
#pragma kernel project
#define expansionMatrix (uint2x2(3, 1, 1 ,3))
#define IX(i) ((i).x * N + (i).y)

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
struct cell
{
    float2 u; // vector at one pos
    float dens; // desnisty

    float soures; // where some is emitted
};

RWTexture2D<float4> Result;
RWStructuredBuffer<cell> data0; // read to
RWStructuredBuffer<cell> data1; // write to
// these get swapped in the c# script so no buffer swap shit in here

int buff;
int N; // size

void readData(inout cell c, inout cell neigh[4], int buff, uint3 id);
void writeData(cell c, int buff, uint3 id);

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float4 col = 0;
    id += uint3(1, 1, 1); // ensure that the edges arn't written to,
    // weird shit alert: the edge edge cell write to the egde cell they are adjesent to
    // this is a hacky fix but i need for consevation of mass
    cell c;
    cell neigh[4];
    readData(c, neigh, buff, id);



    Result[id.xy] = col; // ensure offset
} // this kernel draws to sceen
[numthreads(8,8,1)]
void diffusion (uint3 id : SV_DispatchThreadID)
{
    float4 col = 0;
    id += uint3(1, 1, 1); // ensure that the edges arn't written to,
    // weird shit alert: the edge edge cell write to the egde cell they are adjesent to
    // this is a hacky fix but i need for consevation of mass
    cell c;
    cell neigh[4];
    readData(c, neigh, buff, id);



    writeData(c, buff, id);
} // calculate diffusion
[numthreads(8,8,1)]
void advect (uint3 id : SV_DispatchThreadID)
{
    float4 col = 0;
    id += uint3(1, 1, 1); // ensure that the edges arn't written to,
    // weird shit alert: the edge edge cell write to the egde cell they are adjesent to
    // this is a hacky fix but i need for consevation of mass
    cell c;
    cell neigh[4];
    readData(c, neigh, buff, id);



    writeData(c, buff, id);
} // calculate advect
[numthreads(8,8,1)]
void add_source (uint3 id : SV_DispatchThreadID)
{
    float4 col = 0;
    id += uint3(1, 1, 1); // ensure that the edges arn't written to,
    // weird shit alert: the edge edge cell write to the egde cell they are adjesent to
    // this is a hacky fix but i need for consevation of mass
    cell c;
    cell neigh[4];
    readData(c, neigh, buff, id);



    writeData(c, buff, id);
} // calculate soucre addtion
[numthreads(8,8,1)]
void project (uint3 id : SV_DispatchThreadID)
{
    float4 col = 0;
    id += uint3(1, 1, 1); // ensure that the edges arn't written to,
    // weird shit alert: the edge edge cell write to the egde cell they are adjesent to
    // this is a hacky fix but i need for consevation of mass
    cell c;
    cell neigh[4];
    readData(c, neigh, buff, id);



    writeData(c, buff, id);
} // calculate projection
void readData(inout cell c, inout cell neigh[4], int buff, uint3 id) {
    if (buff == 0) {
        c = data0.Load(IX(id));
        neigh[0] = data0.Load(IX(id + uint3(0, +1, 0)));
        neigh[1] = data0.Load(IX(id + uint3(+1, 0, 0)));
        neigh[2] = data0.Load(IX(id + uint3(0, -1, 0)));
        neigh[3] = data0.Load(IX(id + uint3(-1, 0, 0)));
    }
    else {
        c = data1.Load(IX(id));
        neigh[0] = data1.Load(IX(id + uint3(0, +1, 0)));
        neigh[1] = data1.Load(IX(id + uint3(+1, 0, 0)));
        neigh[2] = data1.Load(IX(id + uint3(0, -1, 0)));
        neigh[3] = data1.Load(IX(id + uint3(-1, 0, 0)));
    } 
}
void writeData(cell c, int buff, uint3 id){
    if (buff == 0) {
        data0[IX(id)] = c;
    }
    else {
        data1[IX(id)] = c;
    }
}

